#version 330 core

uniform float time;
in vec3 color;
out vec4 FragColor;

float rand(vec2 co) {
    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);
}

float scale_from_0_to_1(float min, float max, float value) {
    return (value - min) / (max - min);
}

float diminishing(float x) {
    return (1-exp(-x));
}

vec3 diminishing3(vec3 color) {
    //color.x = diminishing(color.x);
    //color.y = diminishing(color.y);
    //color.z = diminishing(color.z);
    float length_0 = length(color);
    float length_1 = diminishing(length_0);
    color *= length_1 / length_0;
    return color;
}

float inverse_diminishing(float x) {
    return -log(1-x);
}

vec3 rgb_to_hsl(vec3 rgb) {

    float max_ = max(rgb.x, max(rgb.y, rgb.z));
    float min_ = min(rgb.x, min(rgb.y, rgb.z));
    vec3 hsl;

    hsl.x = 0.0;
    hsl.y = 0.0;
    hsl.z = (max_ + min_) / 2.0;
    if (max_ - min_ == 0.0) return hsl;

    if (max_ == rgb.x) {
        hsl.x = (rgb.y - rgb.z) / (max_ - min_);
    } else if (max_ == rgb.y) {
        hsl.x = (rgb.z - rgb.x) / (max_ - min_) + 2.0;
    } else {
        hsl.x = (rgb.x - rgb.y) / (max_ - min_) + 4.0;
    }
    hsl.x = mod(hsl.x / 6.0, 1.0);
    if ((max_ + min_) == 0.0 || (2.0 - (max_ + min_)) == 0.0) return hsl;

    if (hsl.z < 0.5) {
        hsl.y = (max_ - min_) / (max_ + min_);
    } else {
        hsl.y = (max_ - min_) / (2.0 - (max_ + min_));
    }

    return hsl;
}

float hsl_to_rgb_internal_multiplier(float temp_1, float temp_2, float x) {
    if (x < 1.0/6.0) {
        return temp_2 + (temp_1 - temp_2) * (6.0 * x);
    } else if (x < 1.0/2.0) {
        return temp_1;
    } else if (x < 2.0/3.0) {
        return temp_2 + (temp_1 - temp_2) * (2.0/3.0 - x) * 6.0;
    } else {
        return temp_2;
    }
}

vec3 hsl_to_rgb(vec3 hsl) {
    float temp_1 = 0.0;
    
    if (hsl.z < 0.5) {
        temp_1 = hsl.z * (1.0 + hsl.y);
    } else {
        temp_1 = hsl.z + hsl.y - hsl.z * hsl.y;
    }

    float temp_2 = 2.0 * hsl.z - temp_1;

    // return vec3(temp_1, temp_2, 0.0);

    vec3 rgb_temp;

    rgb_temp.x = mod(hsl.x + 1.0/3.0, 1.0);
    rgb_temp.y = hsl.x;
    rgb_temp.z = mod(hsl.x - 1.0/3.0, 1.0);

    vec3 rgb;

    rgb.x = hsl_to_rgb_internal_multiplier(temp_1, temp_2, rgb_temp.x);
    rgb.y = hsl_to_rgb_internal_multiplier(temp_1, temp_2, rgb_temp.y);
    rgb.z = hsl_to_rgb_internal_multiplier(temp_1, temp_2, rgb_temp.z);

    return rgb;
}

void main()
{

    vec2 uv = gl_FragCoord.xy / vec2(8000.0, 6000.0); // Assuming screen size is 800x600
    float randomValue = rand(uv * 10.0 + rand(vec2(time, log(time)))); // Adjust multiplier to change randomness frequency
    vec3 color_ = color + vec3(randomValue/100);

    //float filmic_factor = 0.1;
    //vec3 rgb0 = diminishing3(color_); // rgb input scaled with falloff
    //float overbright = filmic_factor * length(color) * length(color);
    //hsl1.z = diminishing(inverse_diminishing(hsl0.z) + overbright);
    //hsl1.y = scale_from_0_to_1(0.0, 0.5, hsl1.y);
    //hsl1.z = scale_from_0_to_1(0.3, 1.0, hsl1.z);

    vec3 rgb0;
    vec3 hsl0;
    vec3 hsl1;
    vec3 rgb1;

    for (int i = 0; i < 1; ++i) {
        rgb0 = color_;
        hsl0 = rgb_to_hsl(rgb0);
        hsl1 = hsl0;
        rgb1 = hsl_to_rgb(hsl1);
        rgb0 = rgb1;
    }

    FragColor = vec4(rgb1, 1.0);
}